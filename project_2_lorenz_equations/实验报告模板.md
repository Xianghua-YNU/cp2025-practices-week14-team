# 项目2：洛伦兹方程与确定性混沌 - 实验报告

**学生姓名：** [邱炜程]  
**学号：** [20231050173]  
**完成日期：** [25.5.28]  
**实验时间：** [4h]

---

## 1. 实验目的

### 1.1 主要目标
- [ ] 掌握洛伦兹方程组的数值求解方法
- [ ] 理解确定性混沌的基本概念和特征
- [ ] 分析洛伦兹吸引子的几何结构
- [ ] 研究系统对初始条件的敏感依赖性（蝴蝶效应）

### 1.2 学习要点
- 洛伦兹方程的物理背景和数学形式
- 混沌系统的基本特征
- 奇异吸引子的可视化方法
- 数值积分方法在混沌系统中的应用

---

## 2. 理论背景

### 2.1 洛伦兹方程组

**方程形式：**
dx/dt = σ(y - x)
dy/dt = rx - y - xz  
dz/dt = xy - bz


**标准参数：**
- σ = 10.0
- r = 28.0
- b = 8/3

**初始条件：**
- 基准条件：(0.1, 0.1, 0.1)
- 扰动条件：(0.10001, 0.1, 0.1)

---

## 3. 实验内容与结果

### 3.1 洛伦兹吸引子可视化

**实现方法：**
- 使用`scipy.integrate.solve_ivp`的RK45方法求解
- 时间范围：t ∈ [0, 50]
- 时间步长：dt = 0.01

**3D轨迹图：**
[请在此处插入洛伦兹吸引子的3D图]
![image](https://github.com/user-attachments/assets/19f8db04-527c-4d9c-96ac-5eddf8ed4f4b)

**观察结果：**
- 描述吸引子的形状特征
洛伦兹吸引子呈双涡旋（蝴蝶翅膀）结构，三维空间中轨迹围绕两个中心区域交替缠绕，形成非对称闭合环路，左侧与右侧涡旋通过中间区域过渡，整体似展翅蝴蝶，体现非线性对称美感，是混沌吸引子的典型视觉标识。
- 分析轨道的分布特点
局部聚集与全局遍历：轨道在涡旋内局部缠绕（如左涡旋同心圆、右涡旋螺旋），同时在吸引子范围内全局扩散，覆盖相空间，展现遍历性。
非周期性与自相似：轨迹无周期闭合，局部放大仍显涡旋模式（分形特征），反映 “确定性非周期” 行为。
敏感依赖性：微小初始差异导致轨迹缠绕路径迥异（蝴蝶效应），但均被约束在吸引子内，凸显混沌的 “吸引 - 敏感” 双重属性。
### 3.2 初始条件敏感性分析

**比较结果：**
[请在此处插入x(t)的对比图]
![image](https://github.com/user-attachments/assets/5114f6d9-0965-4fe0-b2eb-ab015205b42e)

**轨道距离演化：**
[请在此处插入距离随时间变化图]
![image](https://github.com/user-attachments/assets/6137a4a3-04b8-4173-b050-f87c2911cfdb)

**分析：**
- 两条轨迹何时开始显著分离
  
- 分离速率与混沌特性的关系

---

## 4. 讨论与结论

### 4.1 主要发现
- 总结洛伦兹系统的混沌特性
- 实验中，微小初始条件差异（如 IC2 与 IC1 的细微区别）引发轨迹在约 30 时间单位后显著分离（轨道距离图中距离骤增），直观呈现 “蝴蝶效应”，验证了洛伦兹系统对初始条件的高度敏感性。轨迹的复杂非线性振荡（如对比图中不规则波动），反映混沌吸引子的存在，体现其混沌动力学本质。
- 分析数值方法的适用性
通过数值模拟（如 Runge-Kutta 法）成功求解洛伦兹方程，绘制的轨迹图和距离演化图清晰展示混沌行为，证明数值方法可有效捕捉初始条件敏感引发的轨迹分离，为混沌系统研究提供可靠工具，适用于模拟复杂非线性动力学过程
### 4.2 实验心得
[在实践中，我掌握了初始条件敏感性分析的步骤，学会运用数值模拟工具（如 MATLAB）求解微分方程、可视化混沌轨迹，提升了数据处理与图表分析能力。通过观察轨迹分离的动态过程，直观感受到混沌系统的复杂性与不可预测性，加深了对非线性动力学的理解。实验不仅巩固了理论知识，还培养了科学探究的思维方式 —— 从细微差异中挖掘系统本质，从复杂现象中提炼规律。这一过程让我认识到，混沌研究不仅是数学与物理的交叉应用，更是对自然界复杂性的深度探索，激发了我对非线性系统进一步研究的兴趣。未来，我将更注重理论与实践结合，运用数值方法探索更多混沌现象，提升解决复杂问题的能力。]

---

## 5. 附录：核心代码片段

```python
def solve_lorenz_equations(sigma=10.0, r=28.0, b=8/3,
                          x0=0.1, y0=0.1, z0=0.1,
                          t_span=(0, 50), dt=0.01):
    """
    求解洛伦兹方程
    
    返回:
        t: 时间点数组
        y: 解数组，形状为(3, n_points)
    """
    # TODO: 使用solve_ivp求解洛伦兹方程 (约3行代码)
    # [STUDENT_CODE_HERE]
    t_eval = np.arange(t_span[0], t_span[1], dt)
    sol = solve_ivp(lambda t, state: lorenz_system(state, sigma, r, b), 
                   t_span, [x0, y0, z0], t_eval=t_eval, method='RK45')
    return sol.t, sol.y

```
